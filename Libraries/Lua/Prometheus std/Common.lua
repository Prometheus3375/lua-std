function InitCommon()
    local common = {}
    -- todo: add repr function
    -- todo: add function to expose tables-libraries into globals scope

    local None = setmetatable({}, {
        __len = function(self) error('None does not support length operator', 2) end,
        __index = function(self, key) error('None does not support indexing', 2) end,
        __newindex = function(self, key, value) error('None does not support indexing', 2) end,
        __tostring = function(self) return 'None' end,
        __ipairs = function(self) return error('None does not support ipairs()', 2) end,
        __pairs = function(self) return error('None does not support pairs()', 2) end,
        __metatable = true,
    })
    
    common.None = None
    
    function common.isNone(ins)
        return rawequal(ins, None)
    end
    
    function common.isNil(ins)
        return rawequal(ins, nil)
    end
    
    function common.isNoneOrNil(ins)
        return rawequal(ins, None) or rawequal(ins, nil)
    end
    
    function common.toNil(ins)
        if rawequal(ins, None) then
            return nil
        end
        return ins
    end
    
    function common.toNone(ins)
        if rawequal(ins, nil) then
            return None
        end
        return ins
    end

    local function not_of_type(ins, typ, level)
        error('instance of type ' .. ins.__name .. ' is not ' .. typ, level)
    end
    
    local function check_methods(ins, save_table, ...)
        local cls = ins.__class
        if save_table[cls] then
            return true
        end
        
        for i, key in ipairs({...}) do
            if type(ins[key]) ~= 'function' then
                return false
            end
        end
        
        save_table[cls] = true
        
        return true
    end
    
    local __meta_weak_keys = {__mode = 'k'}
    local __iterables = setmetatable({}, __meta_weak_keys)
    
    local function isiterable(iterable)
        return check_methods(iterable, __iterables, '__iter')
    end
    
    common.isiterable = isiterable

    function common.iter(iterable)
        if isiterable(iterable) then
            return iterable:__iter()
        end
        
        not_of_type(iterable, 'an iterable', 3)
    end

    local function enumerate_inext(state, index)
        -- 1 - iterator
        -- 2 - state of the iterator
        -- 3 - last value generated by the iterator
        local result = table.pack(state[1](state[2], state[3]))
        local value = result[1]
        if not rawequal(value, nil) then
            state[3] = value
            return index + 1, table.unpack(result, 1, result.n)
        end
    end

    function common.enumerate(iterable, start)
        if isiterable(iterable) then
            return enumerate_inext, {iterable:__iter()}, (start or 1) - 1
        end
        
        not_of_type(iterable, 'an iterable', 3)
    end
    
    local __iterators = setmetatable({}, __meta_weak_keys)
    
    local function isiterator(iterator)
        return check_methods(iterator, __iterators, '__inext', '__iter')
    end
    
    common.isiterator = common.isiterator
    
    function common.inext(iterator)
        if isiterator(iterator) then
            return iterator:__inext()
        end
        
        not_of_type(iterator, 'an iterator', 3)
    end

    -- todo: protect common
    return setmetatable(common, {
        
    })
end
